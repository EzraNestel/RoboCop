#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    InfraCollector,      sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  button3,        sensorTouch)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor3,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//motor3 hasn't been enabled yet
int IR_SENSOR_THRESHOLD = 1000;

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
bool button3_pushed; //flag to store button3 input

void monitorInput()
{
    if(SensorValue(button1) && !button1_pushed)
    {
        button1_pushed = true;
    }

    if(SensorValue(button2) && !button2_pushed)
    {
        button2_pushed = true;
    }

    if(SensorValue(button3) && !button3_pushed)
    {
        button3_pushed = true;
    }
}

// Drive ~1.0m

void turn()
{
      resetMotorEncoder(motor1);
      resetMotorEncoder(motor3);

      while(getMotorEncoder(motor1) <= 550){
      		//Slow motor down as it approaches
     			motor[motor1] = 75 - getEncoderForMotor(motor1)/7;
      		motor[motor2] = 75 - getEncoderForMotor(motor1)/7;
      }

      //resets buttons
      button2_pushed = false;
      button1_pushed = false;

      //stops motors
      motor[motor1] = 0;
      motor[motor2] = 0;

} // end turn

void lower_arm()
{
	resetMotorEncoder(motor3);
	motor[motor3] = 30;
	delay(800);
	motor[motor3] = 0;
	delay(500);
	motor[motor3] = -40;
	delay(200);
	motor[motor3] = 0;
	delay(600);
		    resetMotorEncoder(motor1);
        resetMotorEncoder(motor3);

        while(getMotorEncoder(motor1) >= -1000){
            motor[motor1] = -75 + getMotorEncoder(motor1)/30;
            motor[motor2] = 75 - getMotorEncoder(motor1)/30;
          }
          motor[motor1] = 0;
          motor[motor2] = 0;
	button3_pushed = false;

}// end lower_arm

void drive()
{
	      resetMotorEncoder(motor1);
        resetMotorEncoder(motor3);

     /*   while(getMotorEncoder(motor1) <= 2300){
            motor[motor1] = 75 - getMotorEncoder(motor1)/40;
            motor[motor2] = -75 + getMotorEncoder(motor1)/40;
        } */
            while(SensorValue(sonarSensor) > 20  || SensorValue(sonarSensor) == -1){
            motor[motor1] = 63;
            motor[motor2] = -63;
        }
        button2_pushed = false;
        button1_pushed = false;

        motor[motor1] = 0;
        motor[motor2] = 0;

        lower_arm();

} // end exercise_drive

// Turn ~90 degrees

task main ()
{
	button1_pushed = button2_pushed = button3_pushed = false;
	resetMotorEncoder(motor1);
	resetMotorEncoder(motor3);

	while(true){
			monitorInput();
		if(button2_pushed){
			turn();
			}
		if(SensorValue(InfraCollector) < IR_SENSOR_THRESHOLD){
			drive();
			}
		if(button3_pushed){
			lower_arm();
		  }
	}//while
}//main
