#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    InfraCollector,      sensorReflection)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  button3,        sensorTouch)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor3,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//motor3 hasn't been enabled yet
int IR_SENSOR_THRESHOLD = 1000;

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
bool button3_pushed; //flag to store button3 input

void monitorInput()
{
    if(SensorValue(button1) && !button1_pushed)
    {
        button1_pushed = true;
    }

    if(SensorValue(button2) && !button2_pushed)
    {
        button2_pushed = true;
    }

    if(SensorValue(button3) && !button3_pushed)
    {
        button3_pushed = true;
    }
}

// Slows motor to correctly approach the designated encoder target
void motorApproach(Motor motor_num, int start_speed, int target)
{
    
    // 10% over/undershoot allowed
    while (getMotorEncoder(motor_num) > target - target*.1 || getMotorEncoder(motor_num) < target + target*.1) {
        
        if (getMotorEncoder(motor_num) - target < 150) {
            // If the motor is within 150 degrees of final location begin to slow down
            motor[motor_num] = start_speed - getMotorEncoder(motor_num)/8;
            
        } else {
            motor[motor_num] = start_speed;
        } // if
        
    }
    
    // Stop Motor
    motor[motor_num] = 0;
    
} // motorApproach


// Drive ~1.0m

void turn()
{
      resetMotorEncoder(motor1);
      resetMotorEncoder(motor3);

      while(getMotorEncoder(motor1) <= 550){
      		//Slow motor down as it approaches
     			motor[motor1] = 75 - getEncoderForMotor(motor1)/7;
      		motor[motor2] = 75 - getEncoderForMotor(motor1)/7;
      }

      //resets buttons
      button2_pushed = false;
      button1_pushed = false;

      //stops motors
      motor[motor1] = 0;
      motor[motor2] = 0;

} // end turn

void lower_arm()
{
    
    // Check if arm is at original orientation
    monitorInput();
    if (arm_button == true) {
        resetMotorEncoder(motor3);
    } else {
        while (arm_button == false) {
            monitorInput();
            motor[motor3] = -30; // Assuming the motor turning backwards will lift arms
        }
        resetMotorEncoder(motor3);
    }
    
    // Move arm down
    motorApproach(motor3, 60, 720);
}// end lower_arm

void drive()
{
	      resetMotorEncoder(motor1);
        resetMotorEncoder(motor3);

     /*   while(getMotorEncoder(motor1) <= 2300){
            motor[motor1] = 75 - getMotorEncoder(motor1)/40;
            motor[motor2] = -75 + getMotorEncoder(motor1)/40;
        } */
            while(SensorValue(sonarSensor) > 20  || SensorValue(sonarSensor) == -1){
            motor[motor1] = 63;
            motor[motor2] = -63;
        }
        button2_pushed = false;
        button1_pushed = false;

        motor[motor1] = 0;
        motor[motor2] = 0;

        lower_arm();

} // end exercise_drive

// Turn ~90 degrees

task main ()
{
	button1_pushed = button2_pushed = button3_pushed = false;
	resetMotorEncoder(motor1);
	resetMotorEncoder(motor3);

	while(true){
			monitorInput();
		if(button2_pushed){
			turn();
			}
		if(SensorValue(InfraCollector) < IR_SENSOR_THRESHOLD){
			drive();
			}
		if(button3_pushed){
			lower_arm();
		  }
	}//while
}//main
