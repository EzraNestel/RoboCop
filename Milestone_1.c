#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl1,  button1,        sensorTouch)
#pragma config(Sensor, dgtl2,  button2,        sensorTouch)
#pragma config(Sensor, dgtl3,  button3,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor3,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motor2,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//motor3 hasn't been enabled yet

bool button1_pushed; //flag to store button1 input
bool button2_pushed; //flag to store button2 input
bool button3_pushed; //flag to store button3 input

void monitorInput()
{
    if(SensorValue(button1) && !button1_pushed)
    {
        button1_pushed = true;
    }

    if(SensorValue(button2) && !button2_pushed)
    {
        button2_pushed = true;
    }
	
    if(SensorValue(button3) && !button3_pushed)
    {
        button3_pushed = true;
    }
}

// Drive ~1.0m
void drive()
{
	      resetMotorEncoder(motor1);
        resetMotorEncoder(motor2);

        while(getMotorEncoder(motor1) <= 1500){
            motor[motor1] = 75; //- getMotorEncoder(motor1)/9;
            motor[motor2] = -75;// - getMotorEncoder(motor1)/9;
        }
        button2_pushed = false;
        button1_pushed = false;

        motor[motor1] = 0;
        motor[motor2] = 0;

} // end exercise_drive

// Turn ~90 degrees
void turn()
{
      resetMotorEncoder(motor1);
      resetMotorEncoder(motor2);

      while(getMotorEncoder(motor1) <= 550){
      		//Slow motor down as it approaches
     			motor[motor1] = 100-getEncoderForMotor(motor1)/2;
      		motor[motor2] = 100-getEncoderForMotor(motor1)/2;
      }

      //resets buttons
      button2_pushed = false;
      button1_pushed = false;

      //stops motors
      motor[motor1] = 0;
      motor[motor2] = 0;

} // end turn

void lower_arm() //untested code
{
	resetMotorEncoder(motor3);
	motor[motor3] = 40;
	delay(2000);
	motor[motor3] = 0;
	button3_pushed = false;
}// end lower_arm

task main ()
{
	button1_pushed = button2_pushed = button3_pushed = false;
	resetMotorEncoder(motor1);
        resetMotorEncoder(motor2);
	resetMotorEncoder(motor3);


	while(true){
			monitorInput();
		if(button2_pushed){
			turn();
			}
		if(button1_pushed){
			drive();
			}
		if(button3_pushed){
			lower_arm(); 
		  }
	}//while
}//main
