#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in4,    LEFT_IR_LONG,   sensorReflection)
#pragma config(Sensor, in3,    RIGHT_IR_LONG,  sensorReflection)
#pragma config(Sensor, in2,    RIGHT_IR_SHORT, sensorReflection)
#pragma config(Sensor, in1,    LEFT_IR_SHORT,  sensorReflection)
#pragma config(Sensor, dgtl1,  RedLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl2,  BlueLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl3,  YellowLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  armLimit,       sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor_right,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motor_left,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor_arm,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LONG_IR_SENSOR_THRESHOLD = 250;
int SHORT_IR_SENSOR_THRESHOLD = 400;


const int OFF = 0;
const int ON = 1;

enum T_Operating_State  {
    SEARCH_BEACON = 0,
    DRIVE_TO_BEACON,
    DRIVE_BACKUP,
    CONNECTION,
    REVERSE,
    STOP
};

int connection_dist = 13;

int monitorLightShortRight()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[RIGHT_IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

int monitorLightShortLeft()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[LEFT_IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightLongRight()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[RIGHT_IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

int monitorLightLongLeft()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[LEFT_IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

task main()
{

    // allows 600 msecs for microcontroller to initialize
    delay(600);
		SensorValue(RedLED) = OFF;
		SensorValue(BlueLED) = OFF;
		SensorValue(YellowLED) = OFF;
    // resets all sensor values and variables initially to prevent potential error
    clearTimer(T1);

    // Sets arm to starting position
    while(SensorValue(armLimit) == OFF){
        motor[motor_arm] = 30;
    }//while
    motor[motor_arm] = 0;

    T_Operating_State operating_state = SEARCH_BEACON;

    while(operating_state != STOP)
    {

        switch (operating_state) {
                // Search for location of beacon
            case SEARCH_BEACON:
                // Will having no short ir values stop the long from working?
                if (monitorLightLongRight() >= LONG_IR_SENSOR_THRESHOLD  ||
                    monitorLightLongLeft() >= LONG_IR_SENSOR_THRESHOLD)
                {
                	resetMotorEncoder(motor_arm);
                    // Sensor has found the robot
                    motor[motor_right] = 0;
                    motor[motor_left] = 0;
                    operating_state = DRIVE_TO_BEACON;

                } else if(monitorLightLongRight() < LONG_IR_SENSOR_THRESHOLD  &&
                    			monitorLightLongLeft() < LONG_IR_SENSOR_THRESHOLD)
                {
                    motor[motor_right] = 25;
                    motor[motor_left] = -25;
                    // operating_state = SEARCH_BEACON;
                }
                break;

                // Drive towards beacon
            case DRIVE_TO_BEACON:



								int LR_IR = monitorLightLongRight();
								int LL_IR = monitorLightLongLeft();
								int SR_IR = monitorLightShortRight();
								int SL_IR = monitorLightShortLeft();


								// If no IR reading it returns to SEARCH_BEACON state
                if (//monitorLightShortRight() < SHORT_IR_SENSOR_THRESHOLD &&
                    //monitorLightShortLeft() < SHORT_IR_SENSOR_THRESHOLD  &&
                    LR_IR < LONG_IR_SENSOR_THRESHOLD   &&
                    LL_IR < LONG_IR_SENSOR_THRESHOLD)
                {
                	operating_state = SEARCH_BEACON;
                	break;
                }

                if (SensorValue(sonarSensor) >= 18)
                    {
                        // Robot is over 18cm away from beacon
                    		if ( 	SR_IR > SHORT_IR_SENSOR_THRESHOLD ||
                    					SL_IR > SHORT_IR_SENSOR_THRESHOLD)
                    			{

                    				    if (monitorLightShortRight() > monitorLightShortLeft() + 50)
                    				    	{
            											motor[motor_right] = 25;
            											motor[motor_left] = -25;
        													} else if (monitorLightShortRight() < monitorLightShortLeft() - 50)
        														{
        														motor[motor_right] = -25;
            												motor[motor_left] = 25;
            												} else
            													{
            													motor[motor_right] = -33;
            													motor[motor_left] = -25;
            												}//else

                    			} else if (SR_IR < SHORT_IR_SENSOR_THRESHOLD &&
                    								 SL_IR < SHORT_IR_SENSOR_THRESHOLD)
                    			{
                    				  if (monitorLightLongRight() > monitorLightLongLeft() + 300 &&
                    				  		monitorLightShortRight() < SHORT_IR_SENSOR_THRESHOLD &&
                    							monitorLightShortLeft() < SHORT_IR_SENSOR_THRESHOLD)
                    				  {
            											motor[motor_right] = -40;
            											motor[motor_left] = -30;
            											SensorValue(RedLED) = ON;
            											SensorValue(BlueLED) = OFF;
            											SensorValue(YellowLED) = OFF;

        											} else if (monitorLightLongRight() < monitorLightLongLeft() &&
        																 monitorLightLongRight() < SHORT_IR_SENSOR_THRESHOLD &&
                    								 		 monitorLightShortLeft() < SHORT_IR_SENSOR_THRESHOLD)
        												{
        												motor[motor_right] = -50 ;
            										motor[motor_left] = -25;
            										SensorValue(BlueLED) = ON;
            										SensorValue(RedLED) = OFF;
            										SensorValue(YellowLED) = OFF;
            										} else if (monitorLightShortRight() < SHORT_IR_SENSOR_THRESHOLD &&
                    								 			 monitorLightShortLeft() < SHORT_IR_SENSOR_THRESHOLD)
            											{
            											motor[motor_right] = -41;
            											motor[motor_left] = -35;
            											SensorValue(YellowLED) = ON;
            											SensorValue(RedLED) = OFF;
            											SensorValue(BlueLED) = OFF;
            											}//else
                    				}//else if

                    }// if

                    if (SensorValue(sonarSensor) >= connection_dist - 1 &&
                    	  SensorValue(sonarSensor) <= connection_dist + 4)
                    	{
                    		if (SR_IR > SL_IR - 50 &&
                    				SR_IR < SL_IR + 50)
                    		{
                        	// Robot is in connection zone
                        	motor[motor_left] = 0;
                        	motor[motor_right] = 0;
                        	operating_state = CONNECTION;
													break;
												} else if (SR_IR < SL_IR - 50 &&
                    							 SR_IR > SL_IR + 50)
														{
															if (SR_IR < SL_IR - 50)
                    				    	{
            											motor[motor_right] = -25;
            											motor[motor_left] = 25;
        													} else if (SR_IR > SL_IR + 50)
        														{
        														motor[motor_right] = 25;
            												motor[motor_left] = -25;
            												}
										  			}// else

                    	} else
                    		{
                        // Robot too close to beacon for connection
                    		// change to backup
                        operating_state = DRIVE_BACKUP;
                        break;
                    		}//if

                		break;

                // Robot is too close to robot reverse
            case DRIVE_BACKUP:
                // Backup until within range
                // Endgoal to switch into connection state
            		int ShortDif = monitorLightShortRight() - monitorLightShortLeft();

            		if (monitorLightShortRight() > SHORT_IR_SENSOR_THRESHOLD||
                    monitorLightShortLeft() > SHORT_IR_SENSOR_THRESHOLD ||
                    monitorLightLongRight() > LONG_IR_SENSOR_THRESHOLD  ||
                    monitorLightLongLeft() > LONG_IR_SENSOR_THRESHOLD)
                    {
                    	if (SensorValue(sonarSensor) < connection_dist - 3)
                    	{
                    	motor[motor_right] = 29;
                    	motor[motor_left] = 25;

                 			}	else if (SensorValue(sonarSensor) >= connection_dist - 1 && SensorValue(sonarSensor) <= connection_dist + 3)
                  			{
                  			if (ShortDif < 50 && ShortDif > - 50)
                  				{
                        	// Robot is in connection zone
                        	motor[motor_left] = 0;
                        	motor[motor_right] = 0;
                        	operating_state = CONNECTION;
													break;
													} else
															{
															operating_state = DRIVE_TO_BEACON;
															break;
															}
												}
                		} else
                			{
                			operating_state = SEARCH_BEACON;
                			}


                break;

                // Operate the arm to make beacon connection
            case CONNECTION:
                // Move arm down towards the beacon then switch states
                motor[motor_arm] = -30;
                delay(2050);
              	motor[motor_arm] = 0;

                operating_state = REVERSE;

                break;
               // Reverse from the beacon
            case REVERSE:
                //Drive backwards then switch into stop state
								motor[motor_left] = 30;
								motor[motor_right] = 30;
								delay(1100);
                operating_state = STOP;
                break;

                // Stop operating, task finished
            case STOP:

            		motor[motor_left] = 0;
								motor[motor_right] = 0;
								// SensorValue(RedLED) = ON;
                // Sound buzzers...
                break;
                // Should not happen
            default:
                break;
        }
    } // while

}
