#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LEFT_IR_LONG,   sensorReflection)
#pragma config(Sensor, in2,    RIGHT_IR_LONG,  sensorReflection)
#pragma config(Sensor, in3,    RIGHT_IR_SHORT, sensorReflection)
#pragma config(Sensor, in4,    LEFT_IR_SHORT,  sensorReflection)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  armLimit,       sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor_right,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motor_left,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor_arm,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LONG_IR_SENSOR_THRESHOLD = 300;
int SHORT_IR_SENSOR_THRESHOLD = 400;

int forwardMovement;

const int OFF = 0;
const int ON = 1;

enum T_Operating_State  {
    SEARCH_BEACON = 0,
    DRIVE_TO_BEACON,
    DRIVE_BACKUP,
    CONNECTION,
    REVERSE,
    STOP
};

int connection_dist = 13;

int monitorLightShortRight()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[RIGHT_IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

int monitorLightShortLeft()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[LEFT_IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightLongRight()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[RIGHT_IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

int monitorLightLongLeft()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[LEFT_IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

void turn(int motor_speed)
{
     			motor[motor_right] = motor_speed;
      		motor[motor_left] = -motor_speed;
} // end turn

void operate_arm()
{
   // Amount of rotations along small gear to move arm

   motor[motor_arm] = -30;

   // move arm forward set amount`
   // finish`

} // operateArm` (edited)
void slow_drive(int speed, int sensor_right, int sensor_left)
{
            // If positive right side is getting stronger readings, need to move left
            // If negative left side is getting stronger readings, need to move right
            // Adjust division for less/more turning control

            		if (sensor_right > sensor_left + 13){
            		motor[motor_right] = -speed;
            		motor[motor_left] = -speed - 8;
        			} else if (sensor_right < sensor_left - 13){
        				motor[motor_right] = -speed - 14 ;
            		motor[motor_left] = -speed;
            	} else {
            		motor[motor_right] = -speed - 8;
            		motor[motor_left] = -speed;
            	}//else
} // end slow_drive




task main()
{

    // allows 600 msecs for microcontroller to initialize
    delay(600);

    // resets all sensor values and variables initially to prevent potential error
    clearTimer(T1);

    // Sets arm to starting position
    while(SensorValue(armLimit) == OFF){
        motor[motor_arm] = 30;
    }//while
    motor[motor_arm] = 0;

    T_Operating_State operating_state = SEARCH_BEACON;

    while(operating_state != STOP)
    {

        switch (operating_state) {
                // Search for location of beacon
            case SEARCH_BEACON:
                // Will having no short ir values stop the long from working?
                if (monitorLightLongRight() > LONG_IR_SENSOR_THRESHOLD  &&
                    monitorLightLongLeft() > LONG_IR_SENSOR_THRESHOLD)
                {
                	resetMotorEncoder(motor_arm);
                    // Sensor has found the robot
                    motor[motor_right] = 0;
                    motor[motor_left] = 0;
                    operating_state = DRIVE_TO_BEACON;

                } else
                {
                    turn(25);
                    // operating_state = SEARCH_BEACON;
                }
                break;

                // Drive towards beacon
            case DRIVE_TO_BEACON:

								// If no IR reading it returns to SEARCH_BEACON state
                if (monitorLightShortRight() < SHORT_IR_SENSOR_THRESHOLD &&
                    monitorLightShortLeft() < SHORT_IR_SENSOR_THRESHOLD  &&
                    monitorLightLongRight() < LONG_IR_SENSOR_THRESHOLD   &&
                    monitorLightLongLeft() < LONG_IR_SENSOR_THRESHOLD)
                {
                	operating_state = SEARCH_BEACON;
                	break;
                }

                    if (SensorValue(sonarSensor) >= 15)
                    {
                        // Robot is over 15cm away from beacon
                    		if ( 	monitorLightShortRight() > SHORT_IR_SENSOR_THRESHOLD ||
                    					monitorLightShortLeft() > SHORT_IR_SENSOR_THRESHOLD)
                    			{
                    				slow_drive(23, monitorLightShortRight(), monitorLightShortLeft());

                    			} else if (monitorLightShortRight() < SHORT_IR_SENSOR_THRESHOLD ||
                    					monitorLightShortLeft() < SHORT_IR_SENSOR_THRESHOLD){

                    				slow_drive(30, monitorLightLongRight(), monitorLightLongLeft());
                    			}//else if

                    } else if (SensorValue(sonarSensor) >= connection_dist - 3 && SensorValue(sonarSensor) <= connection_dist + 3)
                    	{
                        // Robot is in connection zone
                        motor[motor_left] = 0;
                        motor[motor_right] = 0;
                        operating_state = CONNECTION;
												break;

                    } else
                    {
                        // Robot too close to beacon for connection
                    		// change to backup
                        operating_state = DRIVE_BACKUP;
                        break;
                    }//if

                break;

                // Robot is too close to robot reverse
            case DRIVE_BACKUP:
                // Backup until within range
                // Endgoal to switch into connection state
            		if (monitorLightShortRight() > SHORT_IR_SENSOR_THRESHOLD||
                    monitorLightShortLeft() > SHORT_IR_SENSOR_THRESHOLD ||
                    monitorLightLongRight() > LONG_IR_SENSOR_THRESHOLD  ||
                    monitorLightLongLeft() > LONG_IR_SENSOR_THRESHOLD)
                    {
                    	if (SensorValue(sonarSensor) < connection_dist - 4)
                    	{
                    	slow_drive(-25, monitorLightShortRight(), monitorLightShortLeft());

                 			}	else if (SensorValue(sonarSensor) >= connection_dist - 4 && SensorValue(sonarSensor) <= connection_dist + 4)
                  			{
                  			motor[motor_right] = 0;
                  			motor[motor_left] = 0;
                				operating_state = CONNECTION;

                				} else
                					{
                						operating_state = SEARCH_BEACON;
                					}
                		}
                break;

                // Operate the arm to make beacon connection
            case CONNECTION:
                // Move arm down towards the beacon then switch states
                operate_arm();
                delay(2000);
              	motor[motor_arm] = 0;

                operating_state = REVERSE;

                break;
               // Reverse from the beacon
            case REVERSE:
                //Drive backwards then switch into stop state
								motor[motor_left] = 30;
								motor[motor_right] = 30;
								delay(800);
                operating_state = STOP;
                break;

                // Stop operating, task finished
            case STOP:

            		motor[motor_left] = 0;
								motor[motor_right] = 0;
								// SensorValue(RedLED) = ON;
                // Sound buzzers...
                break;
                // Should not happen
            default:
                break;
        }
    } // while

}

