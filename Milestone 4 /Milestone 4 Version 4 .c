#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LEFT_IR_LONG,   sensorReflection)
#pragma config(Sensor, in2,    RIGHT_IR_SHORT, sensorReflection)
#pragma config(Sensor, in3,    RIGHT_IR_LONG,  sensorReflection)
#pragma config(Sensor, in4,    LEFT_IR_SHORT,  sensorReflection)
#pragma config(Sensor, dgtl1,  RedLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl2,  BlueLED,        sensorDigitalOut)
#pragma config(Sensor, dgtl3,  YellowLED,      sensorDigitalOut)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  armLimit,       sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor_right,   tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           motor_left,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          motor_arm,     tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LONG_IR_SENSOR_THRESHOLD = 250;
int SHORT_IR_SENSOR_THRESHOLD = 400;


const int OFF = 0;
const int ON = 1;

enum T_Operating_State  {
    SEARCH_BEACON = 0,
    DRIVE_TO_BEACON,
    DRIVE_BACKUP,
    CONNECTION,
    REVERSE,
    STOP
};

int connection_dist = 13;


/***************************************************************************************
 *    Title: LightDetector.c
 *    Author: University of Victoria
 *    Date: 15 February 2019
 *    Code version: 1.0
 *    Availability: https://coursespaces.uvic.ca/pluginfile.php/1780177/course/section/453310/LightDetector.c
 ***************************************************************************************/

int monitorLightShortRight()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[RIGHT_IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

int monitorLightShortLeft()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[LEFT_IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightLongRight()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[RIGHT_IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

int monitorLightLongLeft()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[LEFT_IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

task main()
{

    // allows 600 msecs for microcontroller to initialize
    delay(600);
    
    // resets all sensor values and variables initially to prevent potential error
    clearTimer(T1);

    // Sets arm to starting position
    while(SensorValue(armLimit) == OFF){
        motor[motor_arm] = 30;
    }//while
    motor[motor_arm] = 0;

    T_Operating_State operating_state = SEARCH_BEACON;

    while(operating_state != STOP)
    {
        switch (operating_state) {
                
                // Search for location of beacon
            case SEARCH_BEACON:
                // Will having no short ir values stop the long from working?
                if (monitorLightLongRight() >= LONG_IR_SENSOR_THRESHOLD  ||
                    monitorLightLongLeft() >= LONG_IR_SENSOR_THRESHOLD)
                {
                    // Sensor has found the robot
                    motor[motor_right] = 0;
                    motor[motor_left] = 0;
                    // Allow time for motors to stop moving
                    // Switching instantly from SEARCH_BEACON to DRIVE_TO_BEACON does...
                    // ...not give the motors enough time to stop moving decreasing accuracy
                    delay(300);
                    operating_state = DRIVE_TO_BEACON;
                    break;

                } else if(monitorLightLongRight() < LONG_IR_SENSOR_THRESHOLD  &&
                          monitorLightLongLeft() < LONG_IR_SENSOR_THRESHOLD)
                {
                    // Robot has not yet found the beacon, continue searching
                    motor[motor_right] = 25;
                    motor[motor_left] = -25;
                    operating_state = SEARCH_BEACON;
                }
                break;

                // Drive towards beacon
            case DRIVE_TO_BEACON:

                int short_dif = monitorLightShortRight() - monitorLightShortLeft();
                int long_dif = monitorLightLongRight() - monitorLightLongLeft();

                // Adjustable thresholds to set accuracy of the robots travel (less = straighter)
                int pos_threshold = 50;
                int neg_threshold = -50;


                // If no IR reading it returns to SEARCH_BEACON state
                if (monitorLightLongRight() < LONG_IR_SENSOR_THRESHOLD &&
                    monitorLightLongLeft() < LONG_IR_SENSOR_THRESHOLD)
                    {
                		operating_state = SEARCH_BEACON;
                		break;
                    }
                
                if (SensorValue(sonarSensor) <= connection_dist + 3 &&
                		SensorValue(sonarSensor) >= connection_dist - 2 &&
                		monitorLightShortRight() > SHORT_IR_SENSOR_THRESHOLD &&
                		monitorLightShortLeft() > SHORT_IR_SENSOR_THRESHOLD)
                		{
                            // Robot is in the connection area stop motors
                			motor[motor_right] = 0;
                			motor[motor_left] = 0;
                			operating_state = CONNECTION;
                			break;
                            
                		} else if (SensorValue(sonarSensor) < connection_dist - 2)
                        {
                            // Robot too close, double check position then go to backup
                            motor[motor_right] = 0;
                            motor[motor_left] = 0;
                            delay(200);
                            if (SensorValue(sonarSensor) < connection_dist - 2)
                            {
                                // If the robot is still too close switch to DRIVE_BACKUP
                                // Moving objects infront of sonar sensor could give false positives...
                                // ...adjust the delay to prevent this
                                operating_state = DRIVE_BACKUP;
                            }
                            break;
                            
                		}else
                		{
                            if (monitorLightShortRight() < SHORT_IR_SENSOR_THRESHOLD &&
                                monitorLightShortLeft() < SHORT_IR_SENSOR_THRESHOLD)
                            {
                                if (long_dif < pos_threshold && long_dif > neg_threshold)
                                {
                                    // The robot is pretty much straight, keep going forward
                                    motor[motor_right] = -35;
                                    motor[motor_left] = -30;
                                    break;
                                } else if (long_dif > pos_threshold)
                                {
                                    // Robot too far to the right, turn left more
                                    motor[motor_right] = -30;
                                    motor[motor_left] = -35;
                                    break;
                                } else if (long_dif < neg_threshold)
                                {
                                    // Robot too far to the left, turn right more
                                    motor[motor_right] = -40;
                                    motor[motor_left] = -30;
                                    break;
                                }// if (for differentiation of long sensors)
                            } else
                            {
                                if (short_dif < pos_threshold && short_dif > neg_threshold)
                                {
                                    // Robot is withing threshold travel straight
                                    motor[motor_right] = -29;
                                    motor[motor_left] = -25;
                                    break;
                                } else if (short_dif > pos_threshold)
                                {
                                    // Robot too far right, turn left
                                    motor[motor_right] = 20;
                                    motor[motor_left] = -20;
                                    break;
                                } else if (short_dif < neg_threshold)
                                {
                                    // robot too far left, turn right
                                    motor[motor_right] = -20;
                                    motor[motor_left] = 20;
                                    break;
                                }
                            }//else (for short differentiation of sensors)
                        }//else (if robot is too far away from the beacon to connect)

            case DRIVE_BACKUP:
                // Backup until within range
                // Endgoal to switch into connection state
                int ShortDif = monitorLightShortRight() - monitorLightShortLeft();

                if (monitorLightShortRight() > SHORT_IR_SENSOR_THRESHOLD||
                    monitorLightShortLeft() > SHORT_IR_SENSOR_THRESHOLD ||
                    monitorLightLongRight() > LONG_IR_SENSOR_THRESHOLD  ||
                    monitorLightLongLeft() > LONG_IR_SENSOR_THRESHOLD)
                {
                    if (SensorValue(sonarSensor) < connection_dist - 3)
                    {
                        // Backup straight to get withing zone
                    	motor[motor_right] = 29;
                    	motor[motor_left] = 25;
                    	break;

                    } else if (SensorValue(sonarSensor) >= connection_dist - 1 &&
                               SensorValue(sonarSensor) <= connection_dist + 3)
                    {
                        if (ShortDif < 50 && ShortDif > - 50)
                        {
                        	// Robot is in connection zone
                        	motor[motor_left] = 0;
                        	motor[motor_right] = 0;
                        	operating_state = CONNECTION;
                            break;
                        } else
                        {
                            // Robot is too far away drive forward
                            operating_state = DRIVE_TO_BEACON;
                            break;
                        }
                    }// else if (sonar is withing the connection_dist give or take a few cm)
                } else
                {
                    // If no sensor has a reading of the beacon, go back to search
                    operating_state = SEARCH_BEACON;
                    break;
                }
                break;

            // Operate the arm to make beacon connection
            case CONNECTION:
                // Move arm down towards the beacon then switch states
                motor[motor_arm] = -30;
                delay(2050);
              	motor[motor_arm] = 0;

                // Back out of the beacon area
                operating_state = REVERSE;
                break;
                
               // Reverse from the beacon
            case REVERSE:
                //Drive backwards then switch into stop state
                motor[motor_left] = 30;
                motor[motor_right] = 30;
                delay(1300);
                operating_state = STOP;
                break;

                // Stop operating, task finished
            case STOP:

                motor[motor_left] = 0;
                motor[motor_right] = 0;
                // Sound buzzers...
                break;
                
            default:
                // Should not happen
                break;
        }// switch
    } // while
}// task main
