#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IR_SHORT,      sensorReflection)
#pragma config(Sensor, in2,    IR_LONG,      sensorReflection)
#pragma config(Sensor, dgtl1,  YellowLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl2,  BlueLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl3,  RedLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motor3,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


const int LONG_IR_SENSOR_THRESHOLD = 500;
const int SHORT_IR_SENSOR_THRESHOLD = 1000;

const   int OFF = 0;
const   int ON  = 1;

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightShort()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightLong()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

task main ()
{
    SensorValue(RedLED)= OFF;

    while( true ) {

        // Update sensor values (must be called at least 20 times a second for proper performance).
        int beacon_level_short = monitorLightShort();
        int beacon_level_long = monitorLightLong();

        if (beacon_level_short > SHORT_IR_SENSOR_THRESHOLD && SensorValue(sonarSensor) <= 25 && SensorValue(sonarSensor) >= 10) {
            // Good distance from beacon for cable connection
        		SensorValue(BlueLED) = ON;
        		SensorValue(RedLED) = OFF;
        		SensorValue(YellowLED) = OFF;

        } else if (beacon_level_long > LONG_IR_SENSOR_THRESHOLD && SensorValue(sonarSensor) > 25) {
        		// In line with beacon but too far for connection
        		SensorValue(BlueLED) = OFF;
        		SensorValue(RedLED) = ON;
        		SensorValue(YellowLED) = OFF;

        } else if (beacon_level_short > SHORT_IR_SENSOR_THRESHOLD && SensorValue(sonarSensor) <= 10){
        		// Too close to beacon for cable connection
        		SensorValue(BlueLED) = OFF;
        		SensorValue(RedLED) = OFF;
        		SensorValue(YellowLED) = ON;
        		//reverses if too close
        		motor[motor1] = 30;
        		motor[motor2] = 30;
        		delay(400);
        		motor[motor1] = 0;
        		motor[motor2] = 0;
        } else {
        		// Beacon is not in front of robot
        		SensorValue(BlueLED) = OFF;
        		SensorValue(RedLED) = OFF;
        		SensorValue(YellowLED) = OFF;
        	}
    }  // while(true)
}//main
