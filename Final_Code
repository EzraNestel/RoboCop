#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LEFT_IR_LONG,   sensorReflection)
#pragma config(Sensor, in2,    RIGHT_IR_LONG,  sensorReflection)
#pragma config(Sensor, in3,    RIGHT_IR_SHORT, sensorReflection)
#pragma config(Sensor, in4,    LEFT_IR_SHORT,  sensorReflection)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  armLimit,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor_right,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor_left,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motor_arm,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LONG_IR_SENSOR_THRESHOLD = 350;
int SHORT_IR_SENSOR_THRESHOLD = 500;

const int OFF = 0;
const int ON = 1;

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightShortRight()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[RIGHT_IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

int monitorLightShortLeft()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[LEFT_IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightLongRight()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[RIGHT_IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

int monitorLightLongLeft()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[LEFT_IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong


void turn(int motor_speed)
{
     			motor[motor_right] = motor_speed;
      		motor[motor_left] = -motor_speed;
} // end turn

void operate_arm()
{
   // Amount of rotations along small gear to move arm
   int forwardMovement = -800;

   resetMotorEncoder(motor_arm);

   while (getMotorEncoder(motor_arm) > forwardMovement) {
       motor[motor_arm] = -30;
   }


   // move arm forward set amount`
   // finish`

} // operateArm` (edited)


void slow_drive(int speed)
{
            while(SensorValue(sonarSensor) > 35  || SensorValue(sonarSensor) == -1)
            	{
            		if (monitorLightShortRight() < monitorLightShortLeft()){
            		motor[motor_right] = -speed;
            		motor[motor_left] = -speed + 17;
        			} else if (monitorLightShortRight() > monitorLightShortLeft()){
        				motor[motor_right] = -speed + 15 ;
            		motor[motor_left] = -speed;
            	} else {
            		motor[motor_right] = -speed - 4;
            		motor[motor_left] = -speed;
            	}//else
          }//while
        //stop motors
        motor[motor_right] = 0;
        motor[motor_left] = 0;
} // end slow_drive


task main ()
{
	//allows 600 msecs for microcontroller to initialize
	delay(600);
	//resets all sensor values and variables initially to prevent potential error

	resetMotorEncoder(motor_right);
	resetMotorEncoder(motor_left);
	clearTimer(T1);
	int x = 0;
	// Sets arm to starting position
	while(SensorValue(armLimit) == OFF){
		motor(motor_arm) = 40;
	}
	motor(motor_arm) = 0;

	//infinite loop until beacon detected and lower arm executed
while(true)
	{
		int beacon_level_short_right = monitorLightShortRight();
		int beacon_level_short_left = monitorLightShortLeft();

		int beacon_level_long_right = monitorLightLongRight();
		int beacon_level_long_left = monitorLightLongLeft();

			//checks whether beacon is in range for attachement
	    if(beacon_level_short_right > SHORT_IR_SENSOR_THRESHOLD && SensorValue[sonarSensor] <= 10 && beacon_level_short_left > SHORT_IR_SENSOR_THRESHOLD){
      	operate_arm();
				break;

      //If beacon is > 30cms away drive is initiallized until within 30cms of beacon
      }else if((beacon_level_short_right > SHORT_IR_SENSOR_THRESHOLD || beacon_level_short_left > SHORT_IR_SENSOR_THRESHOLD) && SensorValue[sonarSensor] > 17){
      	slow_drive(25);

    	}else if((beacon_level_long_right > LONG_IR_SENSOR_THRESHOLD || beacon_level_long_left > LONG_IR_SENSOR_THRESHOLD) && SensorValue[sonarSensor] > 17){
    		slow_drive(35);

      //If beacon is not in range robot turns until beacon is spotted
      }else{
				while(monitorLightShortRight() < SHORT_IR_SENSOR_THRESHOLD && monitorLightLongRight() < LONG_IR_SENSOR_THRESHOLD && monitorLightShortRight() < SHORT_IR_SENSOR_THRESHOLD && monitorLightLongRight() < LONG_IR_SENSOR_THRESHOLD){
					if(x%2 == 0){
					//alternates turning left and turning right
					//turns right
     			turn(25);
     			}else {
     			//turns left
     			turn(-25);
     			}
				}//while
				x =+ 1;
     		//stops motors
     		motor[motor_right] = 0;
     		motor[motor_left] = 0;
    	}//else
	}//while
}//main
