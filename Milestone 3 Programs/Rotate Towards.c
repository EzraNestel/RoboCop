#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IR_SHORT,      sensorReflection)
#pragma config(Sensor, in2,    IR_LONG,      sensorReflection)
#pragma config(Sensor, dgtl1,  RedLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl2,  BlueLED,         sensorDigitalOut)
#pragma config(Sensor, dgtl3,  button1,        sensorTouch)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motor3,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//


const int LONG_IR_SENSOR_THRESHOLD = 300;
const int SHORT_IR_SENSOR_THRESHOLD = 2000;

const   int OFF = 0;
const   int ON  = 1;

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightShort()
{
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[IR_SHORT];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightShort

// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
int monitorLightLong()
{
    // execution is started.
    static int minLevelIR1 = 4096;    // Minimum light level seen by IR sensor 1
    static int maxLevelIR1 = 0;            // Maximum light level seen by IR sensor 1
    static int diffLevelIR1 = 0;        // Delta between maximum and minimum seen in last 0.1 seconds

    int lightLevel1 = SensorValue[IR_LONG];

    // Check if 100 msecs have elapsed.
    if ( time1[T1] > 100 )  {

        // 100 msecs have elapsed.  Compute delta of light level.
        diffLevelIR1 = maxLevelIR1 - minLevelIR1;

        // Reset calculation for next 100 msecs.
        maxLevelIR1 = 0;
        minLevelIR1 = 4096;
        clearTimer(T1);

    } else {

        // Check for new minimum/maximum light levels.
        if ( lightLevel1 < minLevelIR1 ) {
            minLevelIR1 = lightLevel1;
        } else if ( lightLevel1 > maxLevelIR1 ) {
            maxLevelIR1 = lightLevel1;
        }
    }

    return(diffLevelIR1);
} // end monitorLightLong

task main ()
{
    SensorValue(RedLED)= OFF;
		int x = 0;
    while( true ) {

        // Update sensor values (must be called at least 20 times a second for proper performance).
        int beacon_level_short = monitorLightShort();
        int beacon_level_long = monitorLightLong();

        if (beacon_level_short > SHORT_IR_SENSOR_THRESHOLD || beacon_level_long > LONG_IR_SENSOR_THRESHOLD && SensorValue(sonarSensor) < 25){
        	//In range of beacon
        	SensorValue(BlueLED) = ON;
        	SensorValue(RedLED) = OFF;
        	motor[motor1] = 0;
        	motor[motor2] = 0;

        } else if (beacon_level_short > SHORT_IR_SENSOR_THRESHOLD || beacon_level_long > LONG_IR_SENSOR_THRESHOLD && SensorValue(sonarSensor) > 25) {
            // Has found beacon
        		SensorValue(RedLED) = ON;
        		SensorValue(BlueLED) = OFF;
            motor[motor1] = -60;
            motor[motor2] = -55;
             x =+ 1;

        } else if(x%2 == 0) {
        		SensorValue(RedLED) = OFF;
        		SensorValue(BlueLED) = OFF;
            motor[motor1] = 25;
            motor[motor2] = -25;

        } else {
        		SensorValue(RedLED) = OFF;
        		SensorValue(BlueLED) = OFF;
            motor[motor1] = -25;
            motor[motor2] = 25;
        }
    }  // while(true)
}//main

