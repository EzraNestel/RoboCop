#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    IR_SHORT,      sensorReflection)
#pragma config(Sensor, in2,    IR_LONG,      sensorReflection)
#pragma config(Sensor, dgtl3,  button1,        sensorTouch)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor1,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor2,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motor3,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

short LONG_IR_SENSOR_THRESHOLD = 600;
short SHORT_IR_SENSOR_THRESHOLD = 2000;


// Perform processing of measurements.
// Should be called with rate of at least 20 Hertz for proper detection of puck.
short monitorLight(short IRsensor)
{
	static short minLevelIR = 4096;	// Minimum light level seen by IR sensor
	static short maxLevelIR = 0;			// Maximum light level seen by IR sensor
	static short diffLevelIR = 0;		// Delta between maximum and minimum seen in last 0.1 seconds

	short lightLevel = SensorValue[IRsensor];

	// Executes while loop for 100 msecs
	while ( time1[T1] > 100 )  {

		// Check for new minimum/maximum light levels.
		if ( lightLevel < minLevelIR ) {
			minLevelIR = lightLevel;
			} else if ( lightLevel > maxLevelIR ) {
			maxLevelIR = lightLevel;
		}
	}//while
			// 100 msecs have elapsed.  Compute delta of light level.
		diffLevelIR = maxLevelIR - minLevelIR;

		// Reset calculation for next 100 msecs.
		maxLevelIR = 0;
		minLevelIR = 4096;
		clearTimer(T1);

	return(diffLevelIR);
}// end monitorLight

/*
void turn()
{
      resetMotorEncoder(motor1);
      while(getMotorEncoder(motor1) <= 100)
      	{
      		//Slow motor down as it approaches
     			motor[motor1] = 20;
      		motor[motor2] = -20;
      	}//while
      //stops motors
      motor[motor1] = 0;
      motor[motor2] = 0;
} // end turn
*/
void lower_arm()
{
	resetMotorEncoder(motor3);
			motor[motor3] = -20 ;
				delay(800);
				motor[motor3] = 0;
				delay(500);
				motor[motor1] = -30;
        motor[motor2] = -30;
        delay(600);
    /*    while(getMotorEncoder(motor3) >= -500)
        	{
            motor[motor1] = -30;
            motor[motor2] = -30;
          }//while
          */
          motor[motor1] = 0;
          motor[motor2] = 0;

}// end lower_arm

void fast_drive()
{
            while(SensorValue(sonarSensor) > 40  || SensorValue(sonarSensor) == -1)
            	{
            	motor[motor1] = 63;
            	motor[motor2] = 63;
        			}
        motor[motor1] = 0;
        motor[motor2] = 0;
} // end fast_drive


void slow_drive()
{
            while(SensorValue(sonarSensor) > 15  || SensorValue(sonarSensor) == -1)
            	{
            	motor[motor1] = 15;
            	motor[motor2] = 15;
        			}
        motor[motor1] = 0;
        motor[motor2] = 0;
} // end slow_drive


task main ()
{
	delay(600);
	resetMotorEncoder(motor1);
	resetMotorEncoder(motor3);

while(true)
	{
	    if(monitorLight(IR_SHORT) > SHORT_IR_SENSOR_THRESHOLD && SensorValue[sonarSensor] <= 15){
      	lower_arm();

      }else if(monitorLight(IR_SHORT) > SHORT_IR_SENSOR_THRESHOLD && SensorValue[sonarSensor] <= 30){
      	slow_drive();

      }else if(monitorLight(IR_LONG) > LONG_IR_SENSOR_THRESHOLD && SensorValue[sonarSensor] > 30){
      	fast_drive();

      }else{
      motor[motor1] = 0;
      motor[motor2] = 0;
     // 	turn();

    	}//else
	}//while
}//main
