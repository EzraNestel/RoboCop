#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    LEFT_IR_LONG,   sensorReflection)
#pragma config(Sensor, in2,    RIGHT_IR_LONG,  sensorReflection)
#pragma config(Sensor, in3,    RIGHT_IR_SHORT, sensorReflection)
#pragma config(Sensor, in4,    LEFT_IR_SHORT,  sensorReflection)
#pragma config(Sensor, dgtl4,  sonarSensor,    sensorSONAR_cm)
#pragma config(Sensor, dgtl9,  armLimit,        sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           motor_right,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port2,           motor_left,        tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port10,          motor_arm,        tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int LONG_IR_SENSOR_THRESHOLD = 350;
int SHORT_IR_SENSOR_THRESHOLD = 500;

const int OFF = 0;
const int ON = 1;

enum T_Operating_State = {
    SEARCH_BEACON = 0,
    DRIVE_TO_BEACON,
    DRIVE_BACKUP,
    CONNECTION,
    REVERSE,
    STOP
};

int connection_dist = 13;

int monitorLightShortRight();
int monitorLightShortLeft();
int monitorLightLongRight();
int monitorLightLongLeft();

void turn(int motor_speed);
void operate_arm();
void slow_drive(int speed, int sensor_right, int sensor_left,);

// Copy everything below this comment
task main()
{
    
    // allows 600 msecs for microcontroller to initialize
    delay(600);
    
    // resets all sensor values and variables initially to prevent potential error
    resetMotorEncoder(motor_right);
    resetMotorEncoder(motor_left);
    clearTimer(T1);

    // Sets arm to starting position
    while(SensorValue(armLimit) == OFF){
        motor[motor_arm] = 30;
    } // while
    
    motor(motor_arm) = 0;
    
    T_Operating_State operating_state = SEARCH_BEACON;
    
    while(operating_state != STOP)
    {
        int beacon_level_short_right = monitorLightShortRight();
        int beacon_level_short_left = monitorLightShortLeft();
        
        int beacon_level_long_right = monitorLightLongRight();
        int beacon_level_long_left = monitorLightLongLeft();
        
        int sonar_value = SensorValue[sonarSensor];
        
        switch (operating_state) {
                // Search for location of beacon
            case SEARCH_BEACON:
                // Will having no short ir values stop the long from working?
                if (beacon_level_short_right < SHORT_IR_SENSOR_THRESHOLD &&
                    beacon_level_short_left < SHORT_IR_SENSOR_THRESHOLD &&
                    beacon_level_long_right < LONG_IR_SENSOR_THRESHOLD &&
                    beacon_level_long_left < LONG_IR_SENSOR_THRESHOLD)
                {
                    // Sensor has not yet been found
                    turn(25);
                    operating_state = SEARCH_BEACON;
                } else
                {
                    // Sensor has found the robot
                    motor[motor_right] = 0;
                    motor[motor_left] = 0;
                    operating_state = DRIVE_TO_BEACON;
                }
                break;
                
                // Drive towards beacon
            case DRIVE_TO_BEACON;
                // If the short ir or long ir read the beacon drive toward
                if ((beacon_level_short_right < SHORT_IR_SENSOR_THRESHOLD &&
                    beacon_level_short_left < SHORT_IR_SENSOR_THRESHOLD) ||
                    (beacon_level_long_right < LONG_IR_SENSOR_THRESHOLD &&
                    beacon_level_long_left < LONG_IR_SENSOR_THRESHOLD))
                {
                    if (sonar_value > 30)
                    {
                        // Robot is over 30cm away from beacon
                        slow_drive(35, beacon_level_long_right, beacon_level_long_left);
                    } else if (sonar_value < 30 && sonar_value > connection_dist)
                    {
                        // Robot is less than 30cm away from beacon
                        slow_drive(25, beacon_level_short_right, beacon_level_short_left);
                    } else if (sonar_value > connection_dist - 2 && sonar_value < connection_dist + 2){
                        // Robot is in connection zone
                        operating_state = CONNECTION;
                    } else
                    {
                        // Robot too close to beacon for connection
                        operating_state = DRIVE_BACKUP;
                    }//if
                } else
                {
                    // Robot has lost track of the beacon revert back to search
                    operating_state = SEARCH_BEACON;
                } // if
                break;
                
                // Robot is too close to robot reverse
            case DRIVE_BACKUP;
                // Backup until within range
                // Endgoal to switch into connection state
                operating_state = CONNECTION;
                break;
                
                // Operate the arm to make beacon connection
            case CONNECTION;
                // Move arm down towards the beacon then switch states
                operate_arm();
                operating_state = REVERSE;
                break;
               // Reverse from the beacon
            case REVERSE;
                //Drive backwards then switch into stop state
                
                operating_state = STOP;
                break;
                
                // Stop operating, task finished
            case STOP;
                // Sound buzzers...
                break;
                // Should not happen
            default:
                break;
        }
    } // while
    
}
